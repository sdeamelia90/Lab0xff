#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define _USE_MATH_DEFINES
#include <math.h>
#include <time.h>

//Random Cost Matrix Array
#define MAXN 10000
int VERTICES[MAXN] = { 0 };
int EDGES[MAXN] = { 0 };
double RANDOMM[MAXN][MAXN] = { 0 };

//Coordinate Arrays
double X[MAXN] = { 0 };
double Y[MAXN] = { 0 };

//
double PERMUTATE[MAXN];
int CITIES[MAXN];
int PATH[MAXN];

fillVertices(int N) {
    for (int i = 0; i < N; i++)
        VERTICES[i] = i;
}

void swap(char* x, char* y)
{
    char temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

void permute(char* a, int l, int r)
{
    int i;
    if (l == r)
        printf("%s\n", a);
    else
    {
        for (i = l; i <= r; i++)
        {
            swap((a + l), (a + i));
            permute(a, l + 1, r);
            swap((a + l), (a + i));
        }
    }
} 

//First Test Matrix
void GenerateRandomCostMatrix(int vNum, int eCostMax){
    for (int i = 0; i < vNum; i++) {
        for (int j = 0; j < vNum; j++) {
            if (i == j)
                RANDOMM[i][j] = 0;
            else if (i < j)
                RANDOMM[i][j] = rand() % eCostMax;
            else
                RANDOMM[i][j] = RANDOMM[j][i];
        }
    }
}

//Second Test Matrix
void GenerateRandomEuclideanCostMatrix(int vNum, int maxCoordinate) {
    double edgeWeight = 0;
    for (int i = 0; i < vNum; i++) {
        X[i] = rand() % maxCoordinate;
        Y[i] = rand() % maxCoordinate;
    }

    for (int i = 0; i < vNum; i++) {
        for (int j = 0; j < vNum; j++) {
            edgeWeight = pow(pow(X[i] - X[j], 2) + pow((Y[i] - Y[j]),2), 0.5);
            RANDOMM[i][j] = edgeWeight;
        }
    }

}

//Shuffles the array vertices
void randomizeArr(int N) {
    int j = 0;
    int temp = 0;

    for (int i = 1; i < N - 1; i++) {
        j = rand() % (N - 1) + 1;
        temp = VERTICES[i];
        VERTICES[i] = VERTICES[j];
        VERTICES[j] = temp;
    }
}

//Third Test Matrix
GenerateRandomCircularGraphCostMatrix(int N, int radius) {
    double edgeWeight;
    double stepAngle = 0;
    fillVertices(N);
    randomizeArr(N);

    for (int i = 0; i < N; i++) {

        stepAngle = 2 * M_PI / N;
        X[VERTICES[i]] = radius * sin(i * stepAngle);
        Y[VERTICES[i]] = radius * cos(i * stepAngle);
    }

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            edgeWeight = pow(pow(X[i] - X[j], 2) + pow((Y[i] - Y[j]), 2), 0.5);
            RANDOMM[i][j] = edgeWeight;
        }
    }
}

//Greedy Algorithm using the 'nearest neighbor' approach
double greedy(double costMatrix[MAXN][MAXN], int N) {
    double totalDistance = 0;
    int cityCount = 0;
    double smallest = MAXN;
    int min = INT_MAX;
    int tempCity = 0;
    int finalCity = 0;

    //Reset count for multiple runs
    for (int i = 0; i < N; i++)
        CITIES[i] = 0;

    //Keep track of which cities are visited. Start at node 0.
    CITIES[0] = 1;

    //Keep track of the Path. Begin at node 0.
    PATH[0] = 0;
    cityCount++;

    //find the smallest edge connected to current node. 
    //Repeat until all nodes have been visited
    for (int i = 0; i < N - 1; i++) {
        for (int j = 0; j < N; j++) {
            //Check if next edge is smaller
            if ((smallest > costMatrix[tempCity][j]) && (tempCity != j)) {
                //Double check that node has not been visited.
                if (CITIES[j] == 0) {
                    smallest = costMatrix[tempCity][j];
                    finalCity = j;
                }
            }
        }

        CITIES[finalCity] = 1;
        PATH[cityCount] = finalCity;
        tempCity = finalCity;
        cityCount++;
        totalDistance = totalDistance + smallest;
        smallest = MAXN;
    }
    //Return to Node 0

    totalDistance = totalDistance + costMatrix[0][tempCity];
    PATH[cityCount] = 0;
    return totalDistance;
}

//Print Matrix
void printMatrix(int vNum, double Matrix[MAXN][MAXN]) {
    for (int i = 0; i < vNum; i++) {
        for (int j = 0; j < vNum; j++) {
            printf("%.2lf ", Matrix[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

void printPath(int N, double totalDistance) {

    printf("Path Start->");
    for (int i = 0; i < N; i++) {
        printf("%d ->", PATH[i]);
    }
    printf("%d ->End\n", PATH[N]);
    printf("Total Shortest Distance: %lf\n\n", totalDistance);

}

void printVertices(int N) {
    printf("Vertices: ");
    for (int i = 0; i < N; i++)
        printf("%d ", VERTICES[i]);
    printf("\n");
}

void printTable(int timeCount, double TIME[], int sort) {
    printf("%12s %14s %20s %16s %16s \n", "Power of 2", "  N  ", "Measured Time(s)", "Dbling Ratio", "Expected Ratio");
    printf("======================================================================================================\n");
    double n = 2;
    double doubleRatio = 0;
    double theoryRatio = 0;
    printf("%12d %12d %22.8lf %16s %16s\n", 0, 1, TIME[0], "-", "-");

    for (int i = 1; i < timeCount; i++) {
        if ((TIME[i - 1] == 0) | (TIME[i - 1] == -0)) {
            doubleRatio = 0;
        }
        else {
            doubleRatio = TIME[i] / TIME[i - 1];
        }
        if (sort == 1) {
            theoryRatio = 4.0;
        }
        else if (sort == 2) {
            theoryRatio = log2(n) / (log2(n) - log2(2));
        }
        else if (sort == 3) {
            theoryRatio = 4.0;
        }
        else if (sort == 4) {
            theoryRatio = 2 * log2(n) / (log2(n) - log2(2));
        }
        printf("%12d %12lld %22.8lf %16.2lf %16.2lf\n", i, (long long int)n, TIME[i], doubleRatio, theoryRatio);
        n = n * 2;
    }
}

void TesterFunction() {
    double totalDistance = 0;

    //test input for 1
    int vNum = 5;
    int eCostMax = 5;

    GenerateRandomCostMatrix(vNum, eCostMax);
    printf("Random Cost Matrix: \n");
    printMatrix(vNum, RANDOMM);

    //test for Greedy
    totalDistance = greedy(RANDOMM, vNum);
    printPath(vNum, totalDistance);

    //test input for 2
    int maxCoordinate = 10;
    GenerateRandomEuclideanCostMatrix(vNum, maxCoordinate);
    printf("Random Euclidean Cost Matrix: \n");
    printMatrix(vNum, RANDOMM);

    //test for Greedy
    totalDistance = greedy(RANDOMM, vNum);
    printPath(vNum, totalDistance);

    //test input for 3
    int radius = 10;
    GenerateRandomCircularGraphCostMatrix(vNum, radius);
    printf("Random Circular Graph Cost Matrix: \n");
    printMatrix(vNum, RANDOMM);

    //test for Greedy
    totalDistance = greedy(RANDOMM, vNum);

    printVertices(vNum);
    printPath(vNum, totalDistance);

}


int main(int argc, int argv) {

    int* ptr = malloc((MAXN * MAXN) * sizeof(int));

    int eCostMax = 5;
    int n;
    double trialsTime_max = .250; // in seconds 

    long long int trialsCount_max = 10000, // increase as needed to avoid time measurements of zero 
        N_min = 1,
        N_max = 10000, // adjust as needed, keep small for debugging 
        trial;

    clock_t splitTimeStamp,
        trialSetStart;

    double splitTime,
        trialSetCount,
        trialSetTime,
        dummySetCount,
        dummySetTime,
        averageTrialTime,
        averageDummyTrialTime,
        estimatedTimePerTrial;

    double timeArr[1000] = { 0 };

    int timeCount = 0,
        sort = 0;


    // If you are printing a results table directly, print your header line here. 



    // For each size N of input we want to test -- typically start N at 1 and double each repetition 

    for (n = 1; n < N_max; n = n * 2) {



        /********* any preparations, test input generation, to be used for entire trial set ********/


        splitTime = 0.0;

        // get timestamp before set of trials are run: 

        trialSetStart = clock();

        // For each trial trialNumber=1 to Number of Trials per input size: 

        for (trial = 0; trial < trialsCount_max && splitTime < trialsTime_max; trial++) {



            /******** any preparations, test input generation, for a single trial run *********/
            GenerateRandomCostMatrix(n, eCostMax);

            /**** >>>> Call the algorithm function we are testing, using the generated test input <<<<< ******/
            greedy(RANDOMM, n);

            /******* do any "clean up" after running your algorithm ********/



            // get split time -- "split time" just means the total time so far for this tiral set 

            splitTimeStamp = clock(); //  

            // split time is the difference between current split timestamp and the starting time stamp for trial set 

            splitTime = (splitTimeStamp - (double)trialSetStart) / (double)CLOCKS_PER_SEC; // CLOCK_PER_SEC define time.h  

        }

        trialSetCount = (double)trial; // value of trial when loop ends is how many we did 

        trialSetTime = splitTime; // total time for trial set is the last split time 

        averageTrialTime = trialSetTime / trialSetCount; // this is the average tiem per trial, including any prep/overhead 

        /********* NOW DO A "DUMMY" TRIAL SET TO ESTIMATE THE OVERHEAD TIME ********/

        /* We can just repeat this trialSetCount times, which we know should be faster than above */



        splitTime = 0.0;

        // get timestamp before set of dummy trials are run: 

        trialSetStart = clock();

        for (trial = 0; trial < trialSetCount && splitTime < trialsTime_max; trial++) {



            /******** any preparations, test input generation, for a single trial run *********/

            greedy(RANDOMM, n);

            /**** DO NOT Call the algorithm function!!! ******/



            /******* do any "clean up" after running your algorithm ********/



            // get split time -- "split time" just means the total time so far for this tiral set 

            splitTimeStamp = clock(); //  

            // split time is the difference between current split timestamp and the starting time stamp for trial set 

            splitTime = (splitTimeStamp - (double)trialSetStart) / (double)CLOCKS_PER_SEC; // CLOCK_PER_SEC define time.h  

        }

        dummySetCount = (double)trial; // value of trial when loop ends is how many we did, should be same as trialsSetCount 

        dummySetTime = splitTime; // total time for dummy trial set is the last split time 

        averageDummyTrialTime = dummySetTime / dummySetCount; // this is the average tiem per dummy trial, including any prep/overhead 

        estimatedTimePerTrial = averageTrialTime - averageDummyTrialTime; // should be a decent measurement of time taken to run your algorithm 

        /************ save and/or print your results here to generate your table of results **************/

        // You should be able to print one row of your results table here. 

        // Calculate doubling ratios and any other results for desired columns in table. 

        // Consider additional columns you include in a more detailed table that may help with debugging or just making sense of results. 

        // May be a good idea to print a row of results to output terminal window or a file, so if your program crashes you still have results to look at 

        // use the fflush(stdout) or fflush(filePointer) or equivalent in C++, to force output so nothing is lost if a crash occurs 

        // can also save data to array(s) for later printing/processing 

        timeArr[timeCount] = estimatedTimePerTrial;
        timeCount++;
    }
    printTable(timeCount, timeArr, 1);

}
